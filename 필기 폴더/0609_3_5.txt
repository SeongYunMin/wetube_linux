{3_5}
웹사이트를 만들기 전에 middleware의 개념을 알아야 한다
미들웨어는 말그대로 미들에 있는 소프트웨어를 의미한다 어디의 미들을 의미할까?
바로 request와 response 사이에 미들웨어가 존재한다
브라우저가 request한 다음, 그리고 나(서버)가 응답하기 전 그 사이에 있다
한가지 알아야 되는게 모든 middleware는 handler 이고 모든 handler는 middleware가 될 수도 있다
우리는 handler 대신에 controller를 쓸 것이다 handleHome 같은게 다 controller이다
모든 컨트롤러는 req, res 뿐만 아니라 또하나의 인자를 가진다 바로 next이다
next는 다음 함수를 호출하는 역할을 한다 이전에 배운 res.end()를 return하는 대신 next() 
를 쓰면 어떻게 되는지 보자 localhost 열어보니 이런! cannot get / 이 떴다
왜 그럴까? 그건 바로 app.get("/", handleHome);에서 handleHome 옆에 다른 함수가 존재하지
않기 때문에 아얘 next 함수 실행 자체가 안 된것이다
흠 일단 이건 차차 해결해보고 middleware 부터 만들어보자 gossipMiddleware 라는 함수 하나
만들었다 그리고 얘는 콘솔창 텍스트 출력과 함께 next() 함수가 작동하게 짰다
그리고 이 gossipMiddleware를 app.get("/", gossipMiddleware, handleHome); 이렇게
handleHome 옆에 두니깐 인제 next()의 역할을 알 수 있게 됐다
인제 user가 홈페이지에 request보내면 우선 gossipMiddleware 실행되고 next로 handleHome이
실행된다 여기서 handleHome은 굳이 말하자면 finalware의 역할을 한다. 즉, 마지막으로
호출되는 함수인 것이다 gossipMiddleware같은 미들웨어도 컨트롤러 역할을 할 수 있다
컨트롤러랑 함수 형태 똑같다 예를 들어 gossipMiddleware 내에 return res.send("hi"); 를
next() 전에 넣게 되면 여타 컨트롤러 처럼 브라우저에 hi를 표시할 것이다
그치만 next 전에 return을 하게 되므로 next는 호출되지 않고 handleHome또한 호출되지 않는다
즉 미들웨어가 미들웨어로서의 역할을 할려면 next() 함수가 그 안에 있어야 한다
그렇기 때문에 모든 미들웨어는 컨트롤러이지만 그렇다고 모든 컨트롤러가 미들웨어인 것은 아닌 것이다
정리하자면 middleware는 response를 하는 함수가 아니라 작업을 다음 함수에게 넘기는 함수인 것이다
그렇다면 미들웨어에 user의 req.url 정보를 출력하는 코드를 추가해보자

{3_6_Middleware part Two}
const logger = (req, res, next) => {
  console.log("middleware running");
  console.log(`${req.method} ${req.url}`);
  // return res.send("Middleware Here!");
  next();
};

const privateMiddleware = (req, res, next) => {
  const url = req.url;
  if (url === "/protected") {
    console.log("Can't access");
    return res.send("<h1>Not Allowed ❌</h1>");
  }
  console.log("Allowed, you may continue");
  next();
};

const handleHome = (req, res) => {
  return res.send("<h1>I love Middleware</h1>");
};
const handleProtected = (req, res) => {
  return res.send("Welcome to the private lounge");
};
app.use(logger);
app.use(privateMiddleware);
app.get("/", handleHome);
app.get("/protected", handleProtected);

후 인제 app오브젝트의 메서드를 하나 더 배워보자 바로 app.use이다 use는 global middleware
를 만들 수 있게 해준다. 어느 url에서도 작동하는 범용적인 middleware 말이다
app.use를 쓸때는 이걸 쓰는 위치가 중요하다 얘는 미들웨어를 만들므로 무조건 response를 담당하는
finalware 전에 app.use(middleware); 가 와야 한다
인제 브라우저 들어가보자 전이랑 똑같음을 알 수 있다. 그치만 인제는 범용적인 미들웨어를 쓰기때문에
어떤 페이지를 들어가든 미들웨어가 작동한다. 예를들어 localhost: 4000/login 들어가도
콘솔창에 middleware running 이 뜨는 것을 알 수 있다
명심할것! app.use는 글로벌 미들웨어 실행하는 메서드로서 무조건 finalware 보다 전에
와야지 정상적으로 미들웨어 작동한다!
req.method를 쓰면 어떤 방식의 request가 왔는지 알 수 있다
gossipMiddleware의 이름을 logger로 변경하겠다 그리고 prtectionMiddleware 을 하나 더 만들었다
protectionMiddleware는 만약 user가 /protected에 접속했을때 not allowed를
출력하는 미들웨어이다. 코드를 보고 해석해보자 만약(if) url이 /protected라면 res.send로 
not allowed 창에 출력하고 아니면 next(); 를 써서 다음 미들웨어로 넘어가는 코드이다
자 이렇게 코드 짜고 만약 app.get("/prtected",handleProtected); 메서드가 있다고 해보자
url창에 /protected request하면 우선 protectionMiddleware 작동하고 url 검사를 조건문으로
진행한다 조건문에 걸렸으므로 not allowed를 화면상에 출력한다. 이 상황에서 protectionMiddleware
는 next() 가 실행되지 않고 response를 했으므로 컨트롤러가 된 것이다
이 상황에선 logger는 미들웨어, protectionMiddleware 는 파이널웨어로 쓰인 것이다



앞으로 매우 유명한 미들웨어들을 사용해볼 것이다 미들웨어는 중요하므로 숙지하고 있자!!
미들웨어는 사용자가 로그인을 했는지, 안했는지를 확인할때 등에 사용된다
인제 진짜 애플리케이션을 만들어볼 차례이다