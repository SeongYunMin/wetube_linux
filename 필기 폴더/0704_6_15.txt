{6_15_CreatingVideoOne}
스키마는 데이터가 어떤 형태를 가질지를 알려준다 user는 upload페이지에서 데이터를 입력함으로써
이 스키마의 형식에 해당하는 데이터들을 보내줄 수 있다 물론 views, ratings 같은 메타 데이터들은
user에게 자동으로 제공해줄 것이다 즉 비디오 업로드하는 유저는 title, description, hashtags 만
입력하면 된다 자 이전에 post에서 배운걸 토대로 upload.pug에서 description과 hashtags에도
name을 붙여주고 컨트롤러가 데이터를 받을 수 있도록 코드를 짜보자 코드 보고 이해할 수 있을 것이다
이렇게 하면 인제 입력 데이터를 서버에서 받을 수 있게 됐다 자 인제 이 받은 데이터를 가지고
비디오 데이터를 만들어야하는데 어케 할까? 먼저 document를 만들어줘야 한다 document는 데이터를
가진 Video라고 생각하면 편하다 그리고 그 document를 database에 저장해야 한다
postUpload 컨트롤러로 가서 video = new Video() 를 통해 document를 생성할 수 있다 그 안에
스키마에 맞게 얻은 데이터를 집어넣으면 된다 자 근데 문제가 있다 hashtags의 경우 값을 입력받을
때 콤마로 구분하기로 했는데 이 긴 string을 콤마를 기준으로 쪼개서 저장해야 한다
이때 필요한 function이 split이다 string.split(",") 이렇게 해주면 ,를 기준으로 string을 분해
해서 각 엘레먼트를 어레이에 넣어준다 브라우저 관리자 도구 콘솔창에
"food,movies,music".split(",").map(word => `#${word}`) 이거 입력하고 엔터쳐보자
각각이 # 붙은채로 따로따로 분리되어 어레이에 저장됐음을 알 수 있다 map은 각각의 엘레먼트에
대해 괄호 안의 함수를 실행하여 반환 값을 다시 어레이에 집어 넣는 함수이다 매우 유용하다!
이것들을 써서 해쉬태그를 처리해보자 위 코드를 그대로 hashtags 키에다가 적용시켜주면 된다
인제 이렇게 함으로써 video 데이터를 직접 만들 수 있게 됐다 함 업로드해보자 콘솔창에
입력한 값들이 스키마에 맞게 예쁘게 출력됨을 알 수 있다 심지어 데이터의 id도 지정돼있음을 
알 수 있다 이 id는 이 도큐먼트의 고유식별번호이며 시스템이 임의로 정해준다
근데 홈화면에는 여전히 Sorry, Not Found 가 뜬다 즉 database에 저장이 되진 않았다는
뜻이다 콘솔창에서 mongo 들어가서 show dbs 쳐봐도 여전히 wetube database는 존재하지 않는다
우리가 업로드해서 만든 이 데이터는 아직 JS 월드에만 존재한다 즉 아직 저장을 안한 상태라는
것이다 이것은 다음 영상에서 다뤄보갰다
{upload.pug}
extends base.pug
block content 
    form(method="POST")
        input(placeholder="Title", required, type="text", name="title")
        input(placeholder="Description", required, type="text", name="description")
        input(placeholder="Hashtags, seperated by comma.", required, type="text", name="hashtags")
        input(type="submit",value="Upload Video")

{videoControllers 중 postEdit}
export const postUpload = (req, res) => {
  const { title, description, hashtags } = req.body;
  const video = new Video({
    title,
    description,
    createdAt: Date.now(),
    hashtags: hashtags.split(",").map((word) => `#${word}`),
    meta: {
      views: 0,
      rating: 0,
    },
  });
  console.log(video);
  return res.redirect("/");
};

{6_16_CreatingVideoTwo}
자 인제 database에 데이터를 저장해보자 근데 만약에 스키마 형식에 맞지 않는 데이터
예를 들어 title은 string이 와야하는데 title: 5 같이 숫자가 왔을때 mongoose는 이걸 에러로
캐치할까? 도큐먼트 만들때 title: 5 넣어서 에러를 유도해보았다 이렇게 한후 업로드 해보면
에러는 발생하지 않고 콘솔창에는 숫자 5가 아닌 string '5'가 title에 저장돼있음을 알 수 있다
title이 스키마에 맞게 그냥 string으로 변환됐다 즉 number 데어터를 실수로 넣어도 문제없이
몽구스가 string으로 변환을 해준다는 것을 의미한다 이러한 도움으로 좀 더 쾌적한 코딩이 가능하다
만약 ratings,views 같이 숫자만 받아야 하는 항목에 "asdasdad" 같은 문자열을 넣게 되면 어떻게 될까?
문자열을 숫자로 바꾸긴 힘들텐데 말이다. 이럴 경우 시스템은 이 ratings, views 포함된 meta
엘레먼트 자체를 없앤 채로 데이터를 내보낸다 이걸 통해 시스템이 코드를 어느정도 보호하고 있음
을 알 수 있다 즉 올바르지 않은 데이터는 도규먼트에 기록조차 될 수 없게 만들어서 에러를 방지하는
것이다 이런 과정을 validation이라고 한다 즉 데이터가 유효한지 JS가 알아서 검사해주는 것.
자 인제 진짜 데이터를 database에 저장해보자 console.log(video) 지우고 video.save(); 넣자
video.save()는 video가 mongoose model이기 떄문에 사용가능하다 save의 경우 JS 내에서만 작동
하는 함수가 아닌 외부에 즉 mongoDB에 저장을 하는 함수이므로 Promise를 return한다. 즉
save 작업이 끝날때까지 기다려야한다는 것이다 async await을 쓰자 await video.save(); 이렇게
코드 짜주면 기다릴 수 있게 된다